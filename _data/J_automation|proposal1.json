{
  "parentPageId": "proposals",
  "title": "Proposal 1: Delegate and Collapse",
  "description": "Proposed by: Abhishek Chugh \\\nContributors:\n\nThe main contribution of this proposal is to provide the ability to specify known proof patterns without excess repetition easily. It does not \"find\" proofs. Some version of this has probably been implemented in multiple places - IMPROVE, mmj2, OpenAI. Sophize's implementation (using mmj2) is [here](https://github.com/Sophize/METAMATH_SERVER/tree/master/src/main/java/org/sophize/metamath/server). The solution here is most suitable for the quick generation of proofs - which is essential for formal calculators. \n\nThe proposal has two main ideas:\n1. **Modularity**\\\nCreates small, largely self-contained modules that can provide proofs for theorems of a specific type (e.g., sum of numbers, check if a number is prime).\n2. **Recursive specification of proof**\\\nIn most cases, a module author needs only to specify the final step of the proof and delegate the rest of the proof to an existing module.\n\n### Advantages/Features\n1. Similar in spirit to Metamath language - exact steps are specified to reach the proof. Thus, proofs can be generated quickly.\n2. With unification, only a small amount of code will be required for each module.\n3. If needed, we can also specify intricate proof patterns.\n\n### Drawbacks/Limitations\n1. Only exact proof patterns can be specified. No support for 'searching' proofs.\n2. Module authors need to use the same programming language used to implement the architecture.\n3. Each module only knows about the sub-problem it is told to solve. Hence, the combined generated proof may not be the smallest possible.\n\n### Detailed Overview\nThe algorithm that generates the proof consists of two phases. In the first phase, we recursively find sub-proofs required to reach the assertion to be proven. In the second phase, the sub-proofs are combined to produce the result. The combined proof may also contain one or more generated lemmas. Let's see this in action with an example:\n\n> *Modules*: \\\n> NN_LESS_THAN: Generates proofs like  `56 < 231` \\\n> NN0_CLOSURE: Generates proofs like `6 e. NN0` \\\n> NN0_CLOSURE: Generates proofs like `1 e. NN` \\\n>\n> **Input provided**:  ` |- ; 1 5 < ; ; 1 5 1`\n> \n> Module **NN_LESS_THAN** starts generating the proof starting the following *sub-proof*:\n>\n>*Sub-proof1 (`; 1 5 < ; ; 1 5 1`)*\n>| Step | Justification |\n>| -- | -- |\n> | `1 e. NN0` | delegate to NN0_CLOSURE |\n> | `15 e. NN0` | delegate to NN0_CLOSURE |\n> | `5 e. NN0` | delegate to NN0_CLOSURE |\n> | `1 e. NN0` | delegate to NN0_CLOSURE |\n> | `5 e. NN0` | delegate to NN0_CLOSURE |\n> | ` 5 < 10` | delegate to NN_LESS_THAN (self) |\n> | `1 < ; 1 5` |  delegate to NN_LESS_THAN (self) |\n> | `; 1 5 < ; ; 1 5 1` | Using #P_decltc and above steps |\n>\n> For most of the above steps the modules then return one-step proofs stating that they existing theorems in set.mm. Namely, #P_1nn0, #P_5nn0, #P_5lt10. But for the other two steps, the following sub-proofs are generated.\n>\n>*Sub-proof2 (`; 1 5 e. NN0`)*\n>| Step | Justification |\n>| -- | -- |\n> | `1 e. NN0` | delegate to NN0_CLOSURE |\n> | `5 e. NN0` | delegate to NN0_CLOSURE |\n> | `; 1 5 e. NN0` | Using #P_deccl and above steps |\n>\n>*Sub-proof3 (`1 < ; 1 5`)*\n>| Step | Justification |\n>| -- | -- |\n> | `1 e. NN` | delegate to NN_CLOSURE |\n> | `5 e. NN0` | delegate to NN0_CLOSURE |\n> | `1 e. NN0` | delegate to NN0_CLOSURE |\n> | `1 < 10` | delegate to NN_LESS_THAN |\n> | `1< ; 1 5` | Using #P_declti and above steps |\n>\n> After we've found all sub-proofs for all delegated steps, they are collapsed into a single proof (with duplicate steps removed):\n> \n>*Final proof*\n>| Step No | Step | Justification |\n>| --  | -- | -- |\n> | 1 | `1 e. NN0` | #P_1nn0 |\n> | 2 | `5 e. NN0` | #P_5nn0 |\n> | 3 | `15 e. NN0` | #P_deccl (1, 2) |\n> | 4 | `1 e. NN` | #P_1nn |\n> | 5 | `1 < 10` | #P_1lt10 |\n> | 6 | `1 < ; 1 5` | #P_declti (4, 2, 1, 5) |\n> | 7 | `5 <  1 0` | #P_5lt10 |\n> | 8 | `; 1 5 < ; ; 1 5 1` | #P_decltc (1, 3, 2, 1, 7, 6) |\n\n### Open Problems\n1. Not clear how to collapse sub-proofs with distinct variables.\n2. (Unification) In what cases can we automatically figure out substitutions required?",
  "sortHint": 1,
  "contributor": {
    "handle": "abc"
  }
}