{
  "citations" : [ {
    "textCitation" : "[See df-bi on Metamath](http://us.metamath.org/mpegif/df-bi.html)"
  } ],
  "names" : [ "df-bi" ],
  "language" : "METAMATH_SET_MM",
  "lookupTerms" : [ "#T_wn", "#T_wph", "#T_wb", "#T_wps", "#T_wi", "#T_wn", "#T_wph", "#T_wi", "#T_wps", "#T_wi", "#T_wn", "#T_wps", "#T_wi", "#T_wph", "#T_wi", "#T_wn", "#T_wn", "#T_wph", "#T_wi", "#T_wps", "#T_wi", "#T_wn", "#T_wps", "#T_wi", "#T_wph", "#T_wi", "#T_wph", "#T_wb", "#T_wps" ],
  "metaLanguage" : "METAMATH",
  "remarks" : " Define the biconditional (logical 'iff'). The definition ~ df-bi in this section is our first definition, which introduces and defines the biconditional connective ` <-> ` .  We define a wff of the form ` ( ph <-> ps ) ` as an abbreviation for ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` . Unlike most traditional developments, we have chosen not to have a separate symbol such as \"Df.\" to mean \"is defined as.\"  Instead, we will later use the biconditional connective for this purpose ( ~ df-or is its first use), as it allows us to use logic to manipulate definitions directly.  This greatly simplifies many proofs since it eliminates the need for a separate mechanism for introducing and eliminating definitions.  Of course, we cannot use this mechanism to define the biconditional itself, since it hasn't been introduced yet.  Instead, we use a more general form of definition, described as follows. In its most general form, a definition is simply an assertion that introduces a new symbol (or a new combination of existing symbols, as in ~ df-3an ) that is eliminable and does not strengthen the existing language.  The latter requirement means that the set of provable statements not containing the new symbol (or new combination) should remain exactly the same after the definition is introduced.  Our definition of the biconditional may look unusual compared to most definitions, but it strictly satisfies these requirements. The justification for our definition is that if we mechanically replace ` ( ph <-> ps ) ` (the definiendum i.e. the thing being defined) with ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` (the definiens i.e. the defining expression) in the definition, the definition becomes the previously proved theorem ~ bijust .  It is impossible to use ~ df-bi to prove any statement expressed in the original language that can't be proved from the original axioms, because if we simply replace each instance of ~ df-bi in the proof with the corresponding ~ bijust instance, we will end up with a proof from the original axioms. Note that from Metamath's point of view, a definition is just another axiom - i.e. an assertion we claim to be true - but from our high level point of view, we are not strengthening the language.  To indicate this fact, we prefix definition labels with \"df-\" instead of \"ax-\".  (This prefixing is an informal convention that means nothing to the Metamath proof verifier; it is just a naming convention for human readability.) After we define the constant true ` T. ` ( ~ df-tru ) and the constant false ` F. ` ( ~ df-fal ), we will be able to prove these truth table values: ` ( ( T. <-> T. ) <-> T. ) ` ( ~ trubitru ), ` ( ( T. <-> F. ) <-> F. ) ` ( ~ trubifal ), ` ( ( F. <-> T. ) <-> F. ) ` ( ~ falbitru ), and ` ( ( F. <-> F. ) <-> T. ) ` ( ~ falbifal ). See ~ dfbi1 , ~ dfbi2 , and ~ dfbi3 for theorems suggesting typical textbook definitions of ` <-> ` , showing that our definition has the properties we expect.  Theorem ~ dfbi1 is particularly useful if we want to eliminate ` <-> ` from an expression to convert it to primitives. Theorem ~ dfbi shows this definition rewritten in an abbreviated form after conjunction is introduced, for easier understanding. Contrast with ` \\/ ` ( ~ df-or ), ` -> ` ( ~ wi ), ` -/\\ ` ( ~ df-nan ), and ` \\/_ ` ( ~ df-xor ) .  In some sense ` <-> ` returns true if two truth values are equal; ` = ` ( ~ df-cleq ) returns true if two classes are equal.  (Contributed by NM, 27-Dec-1992.) ",
  "statement" : "df-bi $p |- -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) $."
}