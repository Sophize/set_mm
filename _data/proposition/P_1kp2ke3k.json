{
  "citations" : [ {
    "textCitation" : "[See 1kp2ke3k on Metamath](http://us.metamath.org/mpegif/1kp2ke3k.html)"
  } ],
  "names" : [ "1kp2ke3k" ],
  "language" : "METAMATH_SET_MM",
  "lookupTerms" : [ "#T_cdc", "#T_cdc", "#T_cdc", "#T_c1", "#T_cc0", "#T_cc0", "#T_cc0", "#T_caddc", "#T_cdc", "#T_cdc", "#T_cdc", "#T_c2", "#T_cc0", "#T_cc0", "#T_cc0", "#T_wceq", "#T_cdc", "#T_cdc", "#T_cdc", "#T_c3", "#T_cc0", "#T_cc0", "#T_cc0" ],
  "metaLanguage" : "METAMATH",
  "remarks" : " Example for ~ df-dec , 1000 + 2000 = 3000. This proof disproves (by counter-example) the assertion of Hao Wang, who stated, \"There is a theorem in the primitive notation of set theory that corresponds to the arithmetic theorem 1000 + 2000 = 3000.  The formula would be forbiddingly long... even if (one) knows the definitions and is asked to simplify the long formula according to them, chances are he will make errors and arrive at some incorrect result.\"  (Hao Wang, \"Theory and practice in mathematics\" , In Thomas Tymoczko, editor, _New Directions in the Philosophy of Mathematics_, pp 129-152, Birkauser Boston, Inc., Boston, 1986.  (QA8.6.N48).  The quote itself is on page 140.) This is noted in _Metamath:  A Computer Language for Pure Mathematics_ by Norman Megill (2007) section 1.1.3.  Megill then states, \"A number of writers have conveyed the impression that the kind of absolute rigor provided by Metamath is an impossible dream, suggesting that a complete, formal verification of a typical theorem would take millions of steps in untold volumes of books...  These writers assume, however, that in order to achieve the kind of complete formal verification they desire one must break down a proof into individual primitive steps that make direct reference to the axioms.  This is not necessary.  There is no reason not to make use of previously proved theorems rather than proving them over and over...  A hierarchy of theorems and definitions permits an exponential growth in the formula sizes and primitive proof steps to be described with only a linear growth in the number of symbols used.  Of course, this is how ordinary informal mathematics is normally done anyway, but with Metamath it can be done with absolute rigor and precision.\" The proof here starts with ` ( 2 + 1 ) = 3 ` , commutes it, and repeatedly multiplies both sides by ten.  This is certainly longer than traditional mathematical proofs, e.g., there are a number of steps explicitly shown here to show that we're allowed to do operations such as multiplication. However, while longer, the proof is clearly a manageable size - even though every step is rigorously derived all the way back to the primitive notions of set theory and logic.  And while there's a risk of making errors, the many independent verifiers make it much less likely that an incorrect result will be accepted. This proof heavily relies on the decimal constructor ~ df-dec developed by Mario Carneiro in 2015.  The underlying Metamath language has an intentionally very small set of primitives; it doesn't even have a built-in construct for numbers.  Instead, the digits are defined using these primitives, and the decimal constructor is used to make it easy to express larger numbers as combinations of digits. (Contributed by David A. Wheeler, 29-Jun-2016.)  (Shortened by Mario Carneiro using the arithmetic algorithm in mmj2, 30-Jun-2016.) ",
  "statement" : "1kp2ke3k $p |- ( ; ; ; 1 0 0 0 + ; ; ; 2 0 0 0 ) = ; ; ; 3 0 0 0 $."
}