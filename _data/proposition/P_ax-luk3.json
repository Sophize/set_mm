{
  "citations" : [ {
    "textCitation" : "[See ax-luk3 on Metamath](http://us.metamath.org/mpegif/ax-luk3.html)"
  } ],
  "names" : [ "ax-luk3" ],
  "language" : "METAMATH_SET_MM",
  "lookupTerms" : [ "#T_wph", "#T_wi", "#T_wn", "#T_wph", "#T_wi", "#T_wps" ],
  "metaLanguage" : "METAMATH",
  "remarks" : " 3 of 3 axioms for propositional calculus due to Lukasiewicz.  Copy of ~ luk-3 , but introduced as an axiom. One might think that the similar ~ pm2.24 ` ( ph -> ( -. ph -> ps ) ) ` is a valid replacement for this axiom.  But this is not true, ~ ax-3 is not derivable from this modification. This can be shown by a technique using carefully designed operators ` -. ` and ` -> ` on a finite set of primitive statements.  In prepositional logic these statements are ` T. ` and ` F. ` , but we can assume more and other primitives: \"Earth is planet\", \"Mars is a planet\", \"Moon is a planet\", \"A 1 km-sized asteroid will impact on the moon between yr. 10000 and 10010\").  The actual contents of the statements are not important in the end, rather it counts whether they hold unconditionally.  We call any set of operators along with a set of primitive statements a model here. A subset of these primitives are assumed to hold.  The rest may not be (yet) decidable, or definitely wrong.  Axioms are fulfilled, if, no matter what primitive we assign randomly to ` ph ` , ` ps ` , ` ch ` ... , always one of the true primitives results after application of the above mentioned operators.  Any theorem derived from axioms only must then always yield a true statement, too, if the hypotheses are fullfilled. The verification of a particular set of axioms in a given model is tedious and error prone, so I wrote a computer program first checking this for me, and second, hunting for a counter example.  The result is printed below. The three primitive statements are denoted phi0 .. phi2, of these phi1 and phi2 are assumed to be true.  The operators ` -. ` and ` -> ` are given in table form.  Feel free to check that any of ~ ax-luk1 , ~ ax-luk2 , ~ pm2.24 and ~ ax-mp result always in phi1, one of the true statements. But assigning phi2 for ` ph ` , ` ps ` in ~ ax-3 yields phi0, a statement not (known to be) true, so it is not reachable from truth conserving axioms. <HTML> <br><br> ax-3 fails for phi2, phi2<br> Disproving model:<br> test case 9165<br> number of statements: 3<br> always true phi 1 2 <br><br> Negation is defined as<br> ---------------------------------------------------------------------- <table border=\"1\"><td>not phi0 = phi1</td><td>not phi1 = phi0</td> <td>not phi2 = phi0</td></tr></table> <br> Implication is defined as<br> ---------------------------------------------------------------------- <table border=1><tr><td>phi0 -> phi0 = phi1</td><td>phi0 -> phi1 = phi1 </td><td>phi0 -> phi2 = phi1</td></tr><tr><td>phi1 -> phi0 = phi0</td><td> phi1 -> phi1 = phi1</td><td>phi1 -> phi2 = phi1</td></tr><tr><td> phi2 -> phi0 = phi0</td><td>phi2 -> phi1 = phi0</td><td>phi2 -> phi2 = phi0</td></tr></table><br></HTML> (Contributed by Wolf Lammen, 17-Dec-2018.)  (New usage is discouraged.) ",
  "statement" : "ax-luk3 $p |- ( ph -> ( -. ph -> ps ) ) $."
}