{
  "parentPageId": "proposals",
  "title": "Proposal 2: Language Independent Spec",
  "description": "Proposed by: Abhishek Chugh \\\nContributors:\n\nWe want to specify the information required to generate sub-proofs (as mentioned in #(metamath/J_automation/proposal1, 'proposal1')) in plain-text or Metamath language rather than a programming language like C/java. These specifications will be read by a program that will generate the expected proofs.  \n\nAt this stage, this is more like call-for-ideas than an actual proposal. But here are the high-level ideas:\n1. While implementing proposal1, we saw that, in many cases, we only need to identify what kind of proposition is provided and figure out the lemma that we need to apply.\n2. Once we apply the lemma, we need to get proof of the hypotheses of the lemma.\n3. The steps for finding the lemma to apply (given a proposition) can be encoded in a decision-tree-like structure.\n4. In this proposal, we are trying to come up with an encoding for this decision-tree in plain text or Metamath language.\n\n### Advantages/Limitations\n* *Same as #(metamath/J_automation/proposal1, 'proposal1')*\n* Specification is programming language agnostic\n\n### Disadvantages/Drawbacks\n* Implementing the library that understands this spec could be more time consuming\n* Limited capabilities of creating custom proofs compared to #(metamath/J_automation/proposal1, 'proposal1').\n\n\n### Detailed Overview\n\n#### Parse Trees\nParse trees for the input hypothesis/assertion will be heavily used in our decision tree, so it will be useful to review them. As a reference, the parse-tree of the assertion `|- ; 16 e. NN0` looks like so:\n> - assert[] wcel (#T_wcel)\n>   - assert[0] cdc (#T_cdc)\n>     - assert[0][0] c1 (#T_c1)\n>     - assert[0][1] c6 (#T_c6)\n>   - assert[1] cn0  (#T_cn0)\n\n**assrt[$a_1$ $a_2$ ...$a_n$ ]** refers to as sub-node in the parse tree of assertion being proven. E.g. `assert[0 2 1]` is the second child of the third child of the first child of the root node. `assert[]` is the root node itself.\n\n#### Sample Decision tree\n\n*Note*: We are ignoring the cases where sub-proofs are more complicated than the simple application of a lemma with hypotheses. Perhaps we can avoid such a scenario or will come up with a way to specify them in the discussions later.\n\nThe following decision tree contains all the information required for comparing natural numbers, eg. `|- ; 2 7 < ; ; 2 1 7`. It is a simpler example where proofs don't involve any propositions with logical-hypothesis (\\$e) or distinct-variables (\\$d).\n\n> - if (assert[] = wcel)\n>   - if (assert[1] = cn0)\n>      - if (assert[0] = cdc)  apply #P_deccl\n>      - if (assert[1] != cdc) find in (#P_1nn0, #P_2nn0 ...#P_10nn0)\n>   - if (assert[1] = cn0)\n>      - if (assert[0] = cdc)\n>         - if (assert[0][1] = c0) apply #P_decnncl\n>         - if (assert[0][1] != c0) apply #P_decnncl2\n>      - if (assert[0] != cdc) find in (#P_1nn, #P_2nn ...#P_10nn) \n> -----\n>\n> - if (assert[] = wbr)\n>    - if (assert[2] = clt)\n>      - if (assert[0] != cdc and assert[1] != cdc) find in (#P_0lt1, #P_1lt2 ... #P_9lt10, #P_2pos ... #P_10pos)\n>      - if (assert[0] != cdc and assert[1] = cdc)\n>        - if (assert[0] = c10) apply #P_eqbrtri\n>        - if (assert[0] != c10) apply #P_declti\n>      - if (assert[1] = cdc and assert[0] = cdc)\n>         - if (assert[0][0]  = assert[1][0]) apply #P_declt\n>         - if (assert[0][0] != assert[1][0]) apply #P_decltc\n> ----\n> - if (assert is `10 = ; 1 0`) find in (#P_dec10)\n>\n\nNote:  List containing exactly matching propositions may be skipped in the specification. We can match the assertion with all mpe propositions, using a hash-map or some other suitable data structure.",
  "sortHint": 2,
  "contributor": {
    "handle": "abc"
  }
}