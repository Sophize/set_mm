{
  "parentPageId": "proposal2",
  "title": "High Level Specification",
  "description": "The decision tree we saw earlier requires the following high-level components.\n\n### Decision-tree Predicates\nPredicates are various kinds of 'if' conditions that will be used to create branches in the decision-tree.\n\n#### Predicates based on nodes\nThese are going to be the most widely used predicates. The decision tree can use predicates on the parse tree nodes of the assertion or the hypotheses.\n\nSome ideas on their syntax:\n1. `assert[0 2 4]` and `hyp1[0]` specify nodes on the assertion and first hypothesis respectively\n2. `numHyp`: Special keyword for the number of hypotheses in the provided proposition\n3. `assert[0] = cdc` checks the statement at the tree node\n\n#### Naming complex predicates\nTODO: Figure out a suitable way to encode this.\n\nIt would be convenient to make certain predicates reusable by naming them. For example, checking if a node is a number may be defined as \n> isNaturalNumber(node) $:=$ node in (cdc, c0, c1, c2..c9) \\\n> Usage: isNaturalNumber(assert[0][1])\n\n### Predicates on distinct variables\nTODO: Fill this section.\n\n### Predicates using `set.mm` expressions\nSometimes, we may checks that are quite difficult to express using only parse-tree nodes. In such cases, we will need a more sophisticated language to express these. The most obvious way to would be to represent them in a statement parseable in `set.mm`. For example, for proof of statements like `|- ( 4 + 5 ) = 9`, we need to apply #P_addcomli if the first operand is smaller than the second (after this we use #P_5p4e9). This predicate can be expressed as `assert[0][0] < assert[0][1]`  - `assert[0][0]` is the node representing 4 and `assert[0][1]` is the node representing the number 5.\n\n### Actions \nAs we reach the leaf of the decision-tree, we find the action needed to solve the proposition. \n\n#### Applying a lemma\nTODO: Figure out a suitable way to encode this.\n\nFor example, when the proposition to prove is of type `|- ; A B e. NN0`, we need to apply the lemma #P_deccl.\n\n#### Find the exact proposition\nTODO: Figure out a suitable way to encode this.\nIn some cases, we know that the input proposition must be one of the propositions already existing in the database.\n\nFor example, when the proposition to prove is of type `[0-9] e. NN0`, the proposition is already proven using one of #P_0nn0, #P_1nn0 ...# P_9nn0.\n\n*More actions (like 'search') may be defined in the future.*\n\n### Organizing the information\nTODO: Figure our a convenient way to write the decision-tree - possibly splitting into multiple files to reduce indentation.",
  "sortHint": 0,
  "contributor": {
    "handle": "abc"
  }
}