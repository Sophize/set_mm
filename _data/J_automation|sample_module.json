{
  "parentPageId": "proposal1",
  "title": "A sample module",
  "description": "Let's go over a sample module to better understand the various components of a module and how to write them. This module compares any two natural numbers (**NNLessThan**). The implementation of this module is [here.](https://github.com/Sophize/METAMATH_SERVER/blob/master/src/main/java/org/sophize/metamath/server/machines/NNLessThanMachine.java) You don't need to read the code, we will go over the important parts and exclude boilerplate code. If reading on GitHub, keep in mind that in the code, a 'module' is called a **Machine**, and a 'sub-proof' is an **Argument**.\n\n### Is Provable\nGiven an input proposition, the module first checks if it can handle the input. The following shows how the **NNLessThan** module determines this:\n\n```\nboolean canProvideProof(...) {\n    ParseNode assrt = parseFromInput(...); // The input as parsed by mmj2\n\n    // Only handles the '<' relation.\n    if (!assrt.stmt.getLabel().equals(\"wbr\")) return false;\n    if (!assrt.child[2].stmt.getLabel().equals(\"clt\")) return false;\n\n    // Parse the numbers from the input.\n    var operand1 = NumberRepresentation.fromParseNode(assrt.child[0]);\n    var operand2 = NumberRepresentation.fromParseNode(assrt.child[1]);\n\n    // The statement is wrong. Eg. when '18<7' is provided\n    if (operand1.number >= operand2.number) return false;\n\n    // This module works for natural numbers, not negative numbers.\n    if (operand1.number < 0) return false;\n\n    // This module doesn't handle statements like ' ; 0 6 < ; 0 7'\n    if (operand1.zeros != 0 || operand2.zeros != 0) return false;\n\n    // Module can handle everything else.\n    return true;\n}\n```\n### Get Proof\nThe module then generates the appropriate sub-proof based on the input. There are five different cases based on the provided input:\n```\nboolean getProof(...) {\n    ParseNode assrt = parseFromInput(...); // The input as parsed by mmj2.\n    var operand1 = NumberRepresentation.fromParseNode(assrt.child[0]);\n    var operand2 = NumberRepresentation.fromParseNode(assrt.child[1]);\n\n    // Case 1: operand1 and operand2 are less than 10.\n    // The assert already exists in set.mm\n    if (!operand2.decimalFormat) {\n      return getExistingProposition(operand1, operand2);\n    }\n\n    // Case 2: operand2 > 10 and operand1 is a digit.\n    if (operand1.number < 10) {\n      return getCompareWithDigitProof(operand1, operand2);\n    }\n    // Case 3: operand2 > 10 and operand1 is a primitive10 (not  ; 1 0).\n    if (operand1.number == 10 && !operand1.decimalFormat) {\n      return getCompareWithPrimitive10Proof(operand1, operand2);\n    } \n    // Case 4: operand1 and operand2 have different higher parts.\n    if (operand1.number / 10 != operand2.number / 10) {\n      return getCompareWithUnequalHigherPlacesProof(operand1, operand2);\n    } \n    // Case 5: operand1 and operand2 have equal higher parts.\n    return getCompareWithEqualHigherPlacesProof(operand1, operand2);\n}\n```\n\n#### Case 1: Theorem already proved.\nAll digit comparisons already exist in set.mm database. E.g. #P_5pos and #P_4lt7\\\nWe only need to figure out the correct label.\n\n```\ngetExistingProposition (operand1, operand2) {\n    String label;\n    if (operand1.number == 0 && operand2.number > 1) {\n      label = operand2.number + \"pos\";\n    } else {\n      label = operand1.number + \"lt\" + operand2.number;\n    }\n    return Databases.getSetMMStmt(label);\n}\n```\n\n#### Case 3, 4, 5: Simple application of a lemma\nThese three cases are very similar. It requires #P_declt, #P_declti, #P_decltc based on the two values of input numbers.\\\nLet look at the case where the smaller number is a digit, and we need to apply #P_declti. In this case, we only need to figure-out the substitutions to generate the sub-proof - the framework can handle the rest.\n\n```\nprivate Proof getCompareWithDigitProof(operand1, operand2) {\n    var a = new NumberRepresentation(operand2.number / 10);\n    var b = new NumberRepresentation(operand2.number % 10);\n    var substitutions = Map.of(\"A\", a.toString(), \n                               \"B\", b.toString(), \n                               \"C\", operand1.toString());\n    return getProofOfAssrt(DECLTI, substitutions);\n}\n```\nThe following sub-proof is generated when the input is `4 < ; 2 5`:\n>| Step | Justification |\n>| -- | -- |\n> | `2 e. NN` | delegate to NN_CLOSURE |\n> | `5 e. NN0` | delegate to NN0_CLOSURE |\n> | `4 e. NN0` | delegate to NN0_CLOSURE |\n> | `4 < 10` | delegate to NN_LESS_THAN (self) |\n> | `4 < ; 2 5` | Using #P_declti and above steps |\n\nBut how does it know which module to delegate to? If the module writer wishes, they can provide the delegated module for each step. But, it is more convenient to provide a common delegate determiner for the module.\n```\ndelegateDeterminer(ParseNode node) {\n    if (node.stmt.getLabel().equals(\"wbr\")) {\n      var relationLabel = node.child[2].stmt.getLabel();\n     // Delegate back to self.\n      if (relationLabel.equals(\"clt\")) return this;\n    }\n\n    if (node.stmt.getLabel().equals(\"wcel\")) {\n      var setLabel = node.child[1].stmt.getLabel();\n     // Delegate back to nn0 or nn machines as needed.\n      if (setLabel.equals(\"cn0\")) return NN0ClosureMachine.getInstance();\n      if (setLabel.equals(\"cn\")) return NNClosureMachine.getInstance();\n    }\n    return null;\n}\n```\n\n#### Case 2: Custom step in sub-proof\nThere is no direct way to compare 10 with a decimal number. We first need to compare it with decimal 10 (`; 10`) and use #P_dec10 and #P_eqtri to show the proof. For example, to prove `10 < ; 2 7`, the following sub-proof is required.\n\n>| Step | Justification |\n>| -- | -- |\n> | `10 = ; 10` | Using #P_dec10 |\n> | `; 1 0 < ; 2 7` | delegate to NN_LESS_THAN (self) |\n> | `10 < 27` | Using #P_eqbrtri and above steps  |\n\nNote that unlike our previous examples, `10 = ; 1 0` is not simply delegated to another module. We need to specify the first step explicitly. This is done like so:\n```\ngetCompareWithPrimitive10Proof(operand1, operand2) {\n    var eqbrtriSubstitutions =\n        Map.ofEntries(\n            Map.entry(\"A\", PRIMITIVE_10.toString()),\n            Map.entry(\"B\", DECIMAL_10.toString()),\n            Map.entry(\"C\", operand2.toString()),\n            Map.entry(\"R\", \"<\"));\n\n    // 1st step is |- 10 = ; 1 0 (dec10). We don't want delegate. \n    // So, this step explicitly provided.\n    // Everything else (only step 2, in this case) will be delegated.\n    StepFactory stepFactory =  new StepFactory(Map.of(0, DEC10), \n                                               this::delegateDeterminer);\n    return getProofForSetMMAssrt(stepFactory, EQBRTRI, substitutions);\n  }\n```\n\nExplicitly providing steps is awkward, and we should try to avoid it. If we had another module that handled equality of expressions of natural numbers, we could have delegated the first step to it.",
  "sortHint": 0,
  "contributor": {
    "handle": "abc"
  }
}